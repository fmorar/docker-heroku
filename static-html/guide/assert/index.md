[{"bookPath":"guide","title":"How and what to verify","titleId":"guide-assert","hasOtp":true,"hasPageHeader":true},"<h1 id=\"guide-assert\" class=\"refHeader\">How and what to verify<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#guide-assert\"><span class=\"icon icon-link\"></span></a></h1>\n<p><i id=\"p_0\" class=\"pid\"></i>Reach's verification engine ensures that invariants about the state of a program assumed by programmers are held by all possible executions of the program.<a href=\"#p_0\" class=\"pid\">0</a></p>\n<p>\n  <i id=\"p_1\" class=\"pid\"></i>At a high-level, the goal of a programmer getting started with verification is to write down <em>every single assumption they have</em> into the program in the form of <span class=\"snip\">assert</span> statements.\n  For example, if a value, <span class=\"snip\">x</span> is assumed to be smaller than 20, then the programmer should always include <span class=\"snip\">assert(x &lt; 20);</span> in the program.\n  This is not to help the verification engine prove later properties, but is to give the verification engine assumptions that it can attempt to falsify so the programmer can learn if their assumptions are correct.<a href=\"#p_1\" class=\"pid\">1</a>\n</p>\n<p>\n  <i id=\"p_2\" class=\"pid\"></i>At a low-level, the programmer should see the verification engine as a tool to prevent test regressions by encoding tests directly into the program in the form of assertions.\n  For example, suppose that during development and testing, a programmer observes an erroneous state where the variable <span class=\"snip\">y</span> is assigned to the value <span class=\"snip\">41</span>, then the programmer should insert <span class=\"snip\">assert(y != 41);</span> into the program.\n  The programmer should insert this check <em>before</em> they fix the problem in the code.\n  This will ensure that all future versions of the program will also be protected from these problems.<a href=\"#p_2\" class=\"pid\">2</a>\n</p>\n<p>\n  <i id=\"p_3\" class=\"pid\"></i>These high- and low-level perspectives on assertions apply to individual code fragments, like the body of an <span class=\"snip\">only</span> statement, as well as entire functions.\n  For example, if a programmer expects a unary function over integers, <span class=\"snip\">f</span>, to always return a number between <span class=\"snip\">0</span> and <span class=\"snip\">50</span>, then they should write <span class=\"snip\">assert(f(forall(UInt)) &lt;= 50);</span> in their program.\n  Similarly, the unit tests for a function that a developer would normally write in a test suite, should instead be written as a series of assertions in the module that defines a function.<a href=\"#p_3\" class=\"pid\">3</a>\n</p>\n<p>\n  <i id=\"p_4\" class=\"pid\"></i>If you'd like to continue learning about verification, we recommend reading about <a href=\"https://duckduckgo.com/?q=property-based+testing\" target=\"_blank\">\"property-based testing\"</a>.\n  Although most resources on the topic will refer to dynamic, random tools, like <a href=\"https://en.wikipedia.org/wiki/QuickCheck\" target=\"_blank\">QuickCheck</a>, the strategies used transfer automatically to a formally verified context, like Reach.<a href=\"#p_4\" class=\"pid\">4</a>\n</p>\n<p><i id=\"p_5\" class=\"pid\"></i>If you'd like to continue reading about verification in Reach specifically, read <a href=\"/guide/loop-invs/#guide-loop-invs\">the guide section on loop invariants</a>.<a href=\"#p_5\" class=\"pid\">5</a></p>","<ul><li class=\"dynamic\"><a href=\"#guide-assert\">How and what to verify</a></li></ul>"]